{
  "name": "webmake",
  "version": "0.3.20",
  "description": "Bundle CommonJS modules into single script for web browser",
  "keywords": [
    "browser",
    "browserify",
    "build",
    "builder",
    "bundle",
    "cjs",
    "commonjs",
    "generator",
    "deploy",
    "make",
    "modules",
    "package",
    "packager",
    "require",
    "requirejs",
    "web"
  ],
  "author": {
    "name": "Mariusz Nowak",
    "email": "medikoo+webmake@medikoo.com",
    "url": "http://www.medikoo.com/"
  },
  "bin": {
    "webmake": "./bin/webmake"
  },
  "main": "lib/webmake",
  "repository": {
    "type": "git",
    "url": "git://github.com/medikoo/modules-webmake.git"
  },
  "bugs": {
    "url": "https://github.com/medikoo/modules-webmake/issues",
    "email": "medikoo+webmake@medikoo.com"
  },
  "engines": {
    "node": ">=0.8"
  },
  "dependencies": {
    "deferred": "~0.6.5",
    "es5-ext": "~0.9.2",
    "find-requires": "~0.1.6",
    "fs2": "~0.1.5",
    "memoizee": "~0.2.5",
    "next": "~0.3.3",
    "optimist": "0.6.x"
  },
  "scripts": {
    "test": "node ./node_modules/tad/bin/tad lib"
  },
  "devDependencies": {
    "jsdom": "~0.8.3",
    "tad": "~0.1.17"
  },
  "licence": "MIT",
  "optionalDependencies": {},
  "readme": "# modules-webmake\n\n_Bundle CommonJS/Node.js modules for web browsers._\n\n__Webmake allows you to organize JavaScript code for the browser the same way as you do for Node.js.__\n\nThanks to that, you can work with best dependency management system that JavaScript currently has, and easily, without extra boilerplate, reuse your modules in any environment that runs JavaScript _(server, client (any web browser), other custom stuff as e.g. Adobe Photoshop, or even your dishwasher if it speaks JavaScript)_.\n\nIt additionally natively supports __CSS__ and __HTML__ files, which makes it a full stack modules bundler for a web browser.\n\n<img src=\"http://medyk.org/webmake.png\" />\n\nFiles support can be extended to any other format that compiles to one of _.js_, _.json_, _.css_ or _.html_. See __[custom extensions](#extensions)__ for more information.\n\nFor a more in depth look into JavaScript modules and the reason for _Webmake_,\nsee the slides from my presentation at Warsaw's MeetJS: [__JavaScript Modules Done Right__][slides]\n\n___If you wonder how Webmake compares with other solutions, see dedicated [comparison section](#comparison-with-other-solutions)___\n\n## How does dependency resolution work?\n\nAs it has been stated, Webmake completely follows Node.js in that\n\nLet's say in package named _foo_ you have following individual module files:\n\n_add.js_\n\n```javascript\nmodule.exports = function() {\n  var sum = 0, i = 0, args = arguments, l = args.length;\n  while (i < l) sum += args[i++];\n  return sum;\n};\n```\n\n_increment.js_\n\n```javascript\nvar add = require('./add');\nmodule.exports = function(val) {\n  return add(val, 1);\n};\n```\n\n_program.js_\n\n```javascript\nvar inc = require('./increment');\nvar a = 1;\ninc(a); // 2\n```\n\nLet's pack _program.js_ with all it's dependencies so it will work in browsers:\n\n    $ webmake program.js bundle.js\n\nThe generated file _bundle.js_ now contains the following:\n\n```javascript\n(function (modules) {\n  // about 60 lines of import/export path resolution logic\n})({\n  \"foo\": {\n    \"add.js\": function (exports, module, require) {\n      module.exports = function () {\n        var sum = 0, i = 0, args = arguments, l = args.length;\n        while (i < l) sum += args[i++];\n        return sum;\n      };\n    },\n    \"increment.js\": function (exports, module, require) {\n      var add = require('./add');\n      module.exports = function (val) {\n        return add(val, 1);\n      };\n    },\n    \"program.js\": function (exports, module, require) {\n      var inc = require('./increment');\n      var a = 1;\n     inc(a); // 2\n    }\n  }\n})(\"foo/program\");\n```\n\nWhen loaded in browser, _program.js_ module is executed immediately.\n\n### Working with HTML and CSS\n\nTechnically you can construct whole website that way:\n\n_body.html_\n\n```html\n<h1>Hello from NodeJS module</h1>\n<p><a href=\"https://github.com/medikoo/modules-webmake\">See Webmake for more details</a></p>\n```\n\n_style.css_\n\n```css\nbody { font-family: Arial, Helvetica, sans-serif; }\nh1, p { margin: 20px; }\np.footer { font-size: 14px; }\n```\n\n_program.js_\n\n```javascript\ndocument.title = \"Hello from NodeJS module\";\n\nrequire('./style');\n\ndocument.body.innerHTML = require('./body');\n\nvar footer = document.body.appendChild(document.createElement('p'));\nfooter.className = 'footer';\nfooter.innerHTML = 'Generated by Webmake!';\n```\n\nBundle it\n\n    $ webmake program.js bundle.js\n\nSee it working, by including it within document as such:\n\n```html\n<!DOCTYPE html>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n<body><script src=\"bundle.js\"></script>\n```\n\n## Installation\n\n    $ npm install -g webmake\n\n## Usage\n\n### From the shell:\n\n    $ webmake [options] <input> <output>\n\n__input__ - Path to the initial module that should be executed when script is loaded.  \n__output__ - Filename at which browser ready bundle should be saved\n\n#### Options\n\n##### name `string`\n\nName at which program should be exposed in your namespace. Technically just assigns exported module to global namespace.\n\n##### amd `string`\n\nExpose bundle as AMD module. If used together with _[name](#name-string)_ option, module will be defined with provided name.\n\n##### include `string`\n\nAdditional module(s) that should be included but due specific reasons are\nnot picked by parser (can be set multiple times)\n\n##### ext `string`\n\nAdditional extensions(s) that should be used for modules resolution from custom formats e.g. _coffee-script_ or _yaml_.  \nSee [extensions](#extensions) section for more info.\n\n##### sourceMap `boolean`\n\nInclude [source maps][], for easier debugging. Source maps work very well in WebKit and Chrome's web inspector. Firefox's Firebug however has some [issues][firebug issue].\n\n##### ignoreErrors `boolean`\n\nIgnore not parsable require paths (e.g. `require('./lang/' + lang)`) if any.\nDynamic paths in require calls are considered a bad practice and won't be possible with upcoming _ES6 modules_ standard. Still if we deal with modules that do that, we can workaround it by turning this option on, and including missing modules with [`include`](https://github.com/medikoo/modules-webmake/edit/master/README.md#include-string) option.\n\n##### cache `boolean` _programmatical usage only_\n\nCache files content and its calculated dependencies. On repeated request only modified files are re-read and parsed.  \nSpeeds up re-generation of Webmake bundle, useful when Webmake is bound to server process, [see below example](#development-with-webmake).  \nHighly recommended if [extensions](#extensions) are used.\nDefaults to _false_.\n\n### Programmatically:\n\n```javascript\nwebmake(programPath[, options][, callback]);\n```\n\n`webmake` by default returns generated source to callback, but if _output_ path is provided as one of the options, then source will be automatically saved to file\n\n### Development with Webmake\n\nCurrently best way is to use Webmake programmatically and setup a static-file server to generate bundle on each request. Webmake is fast, so it's acceptable approach even you bundle hundreds of modules at once.\n\nYou can setup simple static server as it's shown in following example script.  \n_Example also uses [node-static][] module to serve other static files (CSS, images etc.) if you don't need it, just adjust code up to your needs._\n\n```javascript\n// Dependencies:\nvar createServer = require('http').createServer;\nvar staticServer = require('node-static').Server;\nvar webmake      = require('webmake');\n\n// Settings:\n// Project path:\nvar projectPath  = '/Users/open-web-user/Projects/Awesome';\n// Public folder path (statics)\nvar staticsPath  = projectPath + '/public';\n// Path to js program file\nvar programPath = projectPath + '/lib/public/main.js';\n// Server port:\nvar port = 8000;\n// Url at which we want to serve generated js file\nvar programUrl = '/j/main.js';\n\n// Setup statics server\nstaticServer = new staticServer(staticsPath);\n\n// Initialize http server\ncreateServer(function (req, res) {\n  // Start the flow (new Stream API demands that)\n  req.resume();\n  // Respond to request\n  req.on('end', function () {\n    if (req.url === programUrl) {\n      // Generate bundle with Webmake\n\n      // Send headers\n      res.writeHead(200, {\n        'Content-Type': 'application/javascript; charset=utf-8',\n        // Do not cache generated bundle\n        'Cache-Control': 'no-cache'\n      });\n\n      var time = Date.now();\n      webmake(programPath, { sourceMap: true, cache: true }, function (err, content) {\n        if (err) {\n          console.error(\"Webmake error: \" + err.message);\n          // Expose eventual error brutally in browser\n          res.end('document.write(\\'<div style=\"font-size: 1.6em; padding: 1em;'\n            + ' text-align: left; font-weight: bold; color: red;'\n            + ' position: absolute; top: 1em; left: 10%; width: 80%;'\n            + ' background: white; background: rgba(255,255,255,0.9);'\n            + ' border: 1px solid #ccc;\"><div>Could not generate ' + programUrl\n            + '</div><div style=\"font-size: 0.8em; padding-top: 1em\">'\n            + err.message.replace(/'/g, '\\\\\\'') + '</div></div>\\');');\n          return;\n        }\n\n        // Send script\n        console.log(\"Webmake OK (\" + ((Date.now() - time)/1000).toFixed(3) + \"s)\");\n        res.end(content);\n      });\n    } else {\n      // Serve static file\n      staticServer.serve(req, res);\n    }\n  });\n}).listen(port);\nconsole.log(\"Server started\");\n````\n\n### Using Webmake with Express or Connect\n\nSee [webmake-middleware](https://github.com/gillesruppert/webmake-middleware) prepared by [Gilles Ruppert](http://latower.com/).\n\n### Using Webmake with Grunt\n\nSee [grunt-webmake](https://github.com/sakatam/grunt-webmake) prepared by [Sakata Makoto](https://github.com/sakatam).\n\n### Working with other module systems\n\nWhen you work with old school scripts or framework that uses different modules system, then you'd rather just bundle needed utilities (not whole application) and expose them to global scope.\n\n#### Webassemble -> https://github.com/kenspirit/webassemble\n\nWebassemble written by [Ken Chen](https://github.com/kenspirit) provides a convinient way to expose different packages, written CJS style, to outer scripts. It automatically creates one entry package that does the job and is used as a starting point for a Webmake bundle.\n\n### Extensions\n\n#### Extensions published on NPM\n\n##### JS\n* __CoffeeScript - [webmake-coffee](https://github.com/medikoo/webmake-coffee)__\n\n##### JSON\n* __YAML - [webmake-yaml](https://github.com/medikoo/webmake-yaml)__\n\n##### CSS\n* __LESS - [webmake-less](https://github.com/acdaniel/webmake-less)__\n\n##### HTML\n* __handlebars - [webmake-handlebars](https://github.com/acdaniel/webmake-handlebars)__\n\n__Submit any missing extension via [new issue form](https://github.com/medikoo/modules-webmake/issues/new)__.\n\n#### Using extensions with Webmake\n\nInstall chosen extension:\n\n_EXT should be replaced by name of available extension of your choice_.\n\n    $ npm install webmake-EXT\n\nIf you use global installation of Webmake, then extension also needs to be installed globally:\n\n    $ npm install -g webmake-EXT\n\nWhen extension is installed, you need to ask Webmake to use it:\n\n    $ webmake --ext=EXT program.js bundle.js\n\nSame way if used programmatically:\n\n```javascript\nwebmake(inputPath, { ext: 'EXT' }, cb);\n```\n\nMultiple extensions can be used together:\n\n    $ webmake --ext=EXT --ext=EXT2 program.js bundle.js\n\nProgrammatically:\n\n```javascript\nwebmake(inputPath, { ext: ['EXT', 'EXT2'] }, cb);\n```\n\n#### Providing extensions programmatically\n\nExtension doesn't need to be installed as package, you may pass it programmatically:\n\n```javascript\nwebmake(inputPath, { ext: {\n    name: 'EXT',\n    extension: 'ext',\n    type: 'js',\n    compile: function (source, options) { /* ... */ }\n} }, cb);\n```\nSee [writing extensions](#writing-an-extension-for-a-new-format) section to see how to configure fully working extensions\n\n#### Writing an extension for a new format\n\nPrepare a `webmake-*` NPM package _(replace '*' with name of your extension)_, where main module is configured as in following example:\n\n```javascript\n// Define a file extension of a new format, can be an array e.g. ['xy', 'xyz']\nexports.extension = 'xyz';\n\n// Which type is addressed by extension (can be either 'js', 'json', 'css' or 'html')\nexports.type = 'js';\n\n// Define a compile function, that for given source code, produces valid body of a JavaScript module:\nexports.compile = function (source, options) {\n  // Return plain object, with compiled body assigned to `code` property.\n  return { code: compile(source) };\n\n  // If compilation for some reason is asynchronous then assign promise\n  // (as produced by deferred library) which resolves with expected code body\n  return { code: compileAsync(source) };\n\n  // If custom format provides a way to calculate a source map and `sourceMap` options is on\n  // it's nice to generate it:\n  var data, map, code;\n  if (options.sourceMap) {\n    data = compile(source, { sourceMap: true });\n\n    // Include original file in the map.\n    map = JSON.parse(data.sourceMap);\n    map.sourcesContent = [source];\n    map = JSON.stringify(map);\n\n    code = data.code + '\\n//# sourceMappingURL=data:application/json;base64,' +\n      new Buffer(map).toString('base64') + '\\n';\n\n    return { code: code };\n  }\n};\n```\n#### Writing extesions for either JSON, CSS or HTML\n\nBe sure to state the right type, and return string that reflects addressed format (not JavaScript code)\ne.g. extension for CSS:\n\n```javascript\nexports.type = 'css'\nexports.compile = function (source, options) {\n  return { code: compileToCSS(source) }; // `compileToCSS` returns plain CSS string\n};\n```\n\nPublish it and refer to [Using extensions](#Using-extensions-with-webmake) section for usage instructions.  \nFinally if everything works, please let me know, so I can update this document with link to your extension.\n\n## Comparison with other solutions\n\n### AMD\n\nAMD is different format, and although most popular loader for AMD is named [RequireJS](http://requirejs.org/) it works very differently from _require_ as introduced earlier with CommonJS (one that Webmake handles).\n\nMain idea behind AMD is that dependencies are resolved asynchronously (in contrary to synchronous resolution in case of CommonJS format). Sounds promising, but does it really make things better? Cause of waterfall nature of resolution and large number of HTTP requests not necessary. See [benchmark](https://github.com/medikoo/cjs-vs-amd-benchmark#compare-load-times-of-two-module-systems) that compares resolution speed of both formats when used in development mode.\n\nAgreed advantage of AMD that attributes to its success is that in it's direct form works in a browser (it doesn't require any server setup), which is hard to achieve with CJS style (but [not impossible](https://github.com/creationix/chrome-app-module-loader)). Still due to large number of requests such approach is usually not suitable for production and it appears it's also [not that performant in development mode](https://github.com/medikoo/cjs-vs-amd-benchmark#compare-load-times-of-two-module-systems).\n\nQuirks of AMD style is that it requires you to wrap all your modules with function wrappers, its modules are not runnable in direct form in Node.js and dependency resolution rules are basic and limited if you compare it with design of Node.js + NPM ecosystem.\n\n### Browserify and other CJS bundlers\n\n[Browserify](http://browserify.org/) is most popular CJS bundler, and shares very similar idea. The subtle difference is that Browserify is about porting code as written for Node.js to web browser, so apart of resolving dependencies and bundling the code it struggles to bring what is needed and possible from Node.js API to the browser.\n\nWebmake cares only about bringing NodeJS modules format to other environments. Conceptually it's addition to ECMAScript and not port of Node.js to browser. It makes NodeJS modules format runnable in any environment that speaks at least ECMAScript 3. You can bundle with Webmake for Browser, TV, Adobe Photoshop or maybe a modern dishwasher.\n\nWhen comparing with other CJS bundlers, main difference would be that Webmake completely follows resolution logic as it works in Node.js. It resolves both packages and modules exactly as Node.js, and it doesn't introduce any different ways to do that. Thanks to that, you can be sure that your modules are runnable in it's direct form both on server and client-side.\n\nOther important difference is that Webmake doesn't do full AST scan to parse require's out of modules, it relies on [find-requires](https://github.com/medikoo/find-requires#find-requires--find-all-require-calls) module, which does only what's necessary to resolve dependencies list, and that makes it a noticeably faster solution.\n\n### ES6 modules\n\nSoon to be released, native JavaScript modules spec shares the main concept with CommmonJS. Thanks to that eventual transition will be easy and can be fully automated. First [transpilers](http://square.github.io/es6-module-transpiler/) are already here.\n\nAs soon as the standard will be finalized, implemented in first engines and possibly adapted by Node.js Webmake will support it natively as well, then in a same way it will bundle it either for the sake of a bundle or for any ECMAScript 3+ environment that won't take it in natural way.\n\n## Current limitations of Webmake\n\nThe application calculates dependencies via static analysis of source code\n(with the help of the [find-requires][] module). So in some edge cases\nnot all require calls can be found. You can workaround that with help\nof [`include` option](#include-stringarray)\n\nOnly relative paths and outer packages paths are supported, following will work:\n\n```javascript\nrequire('./module-in-same-folder');\nrequire('./module/path/deeper');\nrequire('./some/very/very/very/long' +\n'/module/path');\nrequire('../../module-path-up'); // unless it doesn't go out of package scope\nrequire('other-package');\nrequire('other-package/lib/some-module');\n```\n\nBut this won't:\n\n```javascript\nrequire('/Users/foo/projects/awesome/my-module');\n```\n\nDifferent versions of same package will collide:  \nLet's say, package A uses version 0.2 of package C and package B uses version 0.3 of the same package. If both package A and B are required, package B will most likely end up buggy. This is because webmake will only bundle the version that was called first. So in this case package B will end up with version 0.2 instead of 0.3.\n\n## Tests [![Build Status](https://api.travis-ci.org/medikoo/modules-webmake.png?branch=master)](https://travis-ci.org/medikoo/modules-webmake)\n\n    $ npm test\n\n## Proud list of SPONSORS!\n\n#### [@puzrin](https://github.com/Phoscur) (Vitaly Puzrin) member of [Nodeca](https://github.com/nodeca)\nVitaly pushed forward development of support for _JSON_ files, [extensions functionality](#extensions), along with [webmake-yaml](https://github.com/medikoo/webmake-yaml) extension. Vitaly is a member of a team that is behind [js-yaml](https://github.com/nodeca/js-yaml) JavaScript YAML parser and dumper, and powerful social platform [Nodeca](http://dev.nodeca.com/). Big Thank You Vitaly!\n\n## Contributors\n\n* [@Phoscur](https://github.com/Phoscur) (Justus Maier)\n  * Help with source map feature\n* [@jaap3](https://github.com/jaap3) (Jaap Roes)\n  * Documentation quality improvements\n\n[slides]:\n  http://www.slideshare.net/medikoo/javascript-modules-done-right\n  'JavaScript Modules Done Right on SlideShare'\n\n[source maps]:\n  http://pmuellr.blogspot.com/2011/11/debugging-concatenated-javascript-files.html\n  'Debugging concatenated JavaScript files'\n\n[firebug issue]:\n  http://code.google.com/p/fbug/issues/detail?id=2198\n  'Issue 2198:\t@sourceURL doesn't work in eval() in some cases'\n\n[find-requires]:\n  https://github.com/medikoo/find-requires\n  'find-requires: Find all require() calls'\n\n[node-static]:\n  https://github.com/cloudhead/node-static\n  'HTTP static-file server module'\n",
  "readmeFilename": "README.md",
  "_id": "webmake@0.3.20",
  "dist": {
    "shasum": "babbe7a3e7bde79518df6ad290aa681ec2b04870"
  },
  "_from": "webmake@~0.3.14",
  "_resolved": "https://registry.npmjs.org/webmake/-/webmake-0.3.20.tgz"
}
